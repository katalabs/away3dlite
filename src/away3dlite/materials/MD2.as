package away3dlite.loaders{	import away3dlite.animators.data.UV;	import away3dlite.animators.data.FaceData;	import away3dlite.animators.data.Frame;	import flash.geom.Vector3D;    import away3dlite.arcane;    import away3dlite.animators.MovieMesh;    import away3dlite.core.utils.*;    import away3dlite.materials.*;        import flash.utils.*;		use namespace arcane;	    /**    * File loader for the Md2 file format.    *     * @author Philippe Ajoux (philippe.ajoux@gmail.com)    */    public class MD2 extends AbstractParser    {		/** @private */        arcane override function prepareData(data:*):void        {        	md2 = Cast.bytearray(data);        				var a:int, b:int, c:int, ta:int, tb:int, tc:int;			var vertices:Vector.<Vector3D> = new Vector.<Vector3D>();			var i:int, uvs:Array = [];			var indices:Array = [];			var uvDatas:Array = []						// Make sure to have this in Little Endian or you will hate you life.			// At least I did the first time I did this for a while.			data.endian = Endian.LITTLE_ENDIAN;			// Read the header and make sure it is valid MD2 file			readMd2Header(data);			if (ident != 844121161 || version != 8)				throw new Error("Error loading MD2 file: Not a valid MD2 file/bad version");			// Vertice setup			// 		Be sure to allocate memory for the vertices to the object			//		These vertices will be updated each frame with the proper coordinates			for (i = 0; i < num_vertices; i++)				vertices.push(new Vector3D(0, 0, 0));			// UV coordinates			//		Load them!			data.position = offset_st;			for (i = 0; i < num_st; i++)				uvs.push(new UV(data.readShort() / skinwidth, (data.readShort() / skinheight)));			// Faces			//		Creates the faces with the proper references to vertices			//		NOTE: DO NOT change the order of the variable assignments here, 			//			  or nothing will work.			data.position = offset_tris;			mesh.faceDatas = new Vector.<FaceData>(num_tris, true);			var j:int = 0;			for (i = 0; i < num_tris; i++)			{				a = data.readUnsignedShort();				b = data.readUnsignedShort();				c = data.readUnsignedShort();				ta = data.readUnsignedShort();				tb = data.readUnsignedShort();				tc = data.readUnsignedShort();				mesh.faceDatas[i] = new FaceData(a, b, c, vertices, Vector.<UV>([uvs[ta], uvs[tb], uvs[tc]]));			}						// Frame animation data			//		This part is a little funky.			data.position = offset_frames;			readFrames(data);			// TODO : optimize/promote to face class			var n:int = -1;			i = 0;						var v0:Vector3D;			var v1:Vector3D;			var v2:Vector3D;						for each (var face:FaceData in mesh.faceDatas)			{				v0 = Frame(mesh.frames[0]).vertices[face.a];				v1 = Frame(mesh.frames[0]).vertices[face.b];				v2 = Frame(mesh.frames[0]).vertices[face.c];								mesh._vertices[i++] = v0.x;				mesh._vertices[i++] = v0.y;				mesh._vertices[i++] = v0.z;								mesh._vertices[i++] = v1.x;				mesh._vertices[i++] = v1.y;				mesh._vertices[i++] = v1.z;				mesh._vertices[i++] = v2.x;				mesh._vertices[i++] = v2.y;				mesh._vertices[i++] = v2.z;				mesh._uvtData.push(face.uvMap[0].u, face.uvMap[0].v, 1);				mesh._uvtData.push(face.uvMap[1].u, face.uvMap[1].v, 1);				mesh._uvtData.push(face.uvMap[2].u, face.uvMap[2].v, 1);								n += 3;								mesh._indices.push(n, n - 1, n - 2);			}			mesh.buildFaces();                        mesh.type = ".Md2";        }                private var md2:ByteArray;        private var ident:int;        private var version:int;        private var skinwidth:int;        private var skinheight:int;        private var framesize:int;        private var num_skins:int;        private var num_vertices:int;        private var num_st:int;        private var num_tris:int;        private var num_glcmds:int;        private var num_frames:int;        private var offset_skins:int;        private var offset_st:int;        private var offset_tris:int;        private var offset_frames:int;        private var offset_glcmds:int;        private var offset_end:int;    	private var mesh:MovieMesh;		/**		 * Reads in all the frames		 */		private function readFrames(data:ByteArray):void		{			var sx:Number, sy:Number, sz:Number;			var tx:Number, ty:Number, tz:Number;			var verts:Vector.<Vector3D>, frame:Frame;			var i:int, j:int, k:int, char:int;						for (i = 0; i < num_frames; i++)			{				verts = new Vector.<Vector3D>();				frame = new Frame("", verts);				sx = data.readFloat();				sy = data.readFloat();				sz = data.readFloat();				tx = data.readFloat();				ty = data.readFloat();				tz = data.readFloat();				k = 0;				for (j = 0; j < 16; j++)				{					char = data.readUnsignedByte();					if (int(char) >= 0x30 && int(char) <= 0x7A && k<3)					{						frame.name += String.fromCharCode(char);					}					if (int(char) >= 0x30 && int(char) <= 0x39)k++; 				}								// Note, the extra data.position++ in the for loop is there 				// to skip over a byte that holds the "vertex normal index"				for (j = 0; j < num_vertices; j++, data.position++)					verts.push(new Vector3D((sx * data.readUnsignedByte() + tx) * scaling, (sy * data.readUnsignedByte() + ty) * scaling, (sz * data.readUnsignedByte() + tz) * scaling));								mesh.addFrame(frame);			}						verts.fixed = true;		}		/**		 * Reads in all that MD2 Header data that is declared as private variables.		 * I know its a lot, and it looks ugly, but only way to do it in Flash		 */		private function readMd2Header(data:ByteArray):void		{			ident = data.readInt();			version = data.readInt();			skinwidth = data.readInt();			skinheight = data.readInt();			framesize = data.readInt();			num_skins = data.readInt();			num_vertices = data.readInt();			num_st = data.readInt();			num_tris = data.readInt();			num_glcmds = data.readInt();			num_frames = data.readInt();			offset_skins = data.readInt();			offset_st = data.readInt();			offset_tris = data.readInt();			offset_frames = data.readInt();			offset_glcmds = data.readInt();			offset_end = data.readInt();		}            	/**    	 * A scaling factor for all geometry in the model. Defaults to 1.    	 */        public var scaling:Number = 1;            	/**    	 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.    	 */        public var centerMeshes:Boolean;            	/**    	 * Overrides all materials in the model.    	 */        public function get material():Material        {        	return mesh.material;        }        public function set material(val:Material):void        {        	mesh.material = val;        }        		/**		 * Creates a new <code>Md2</code> object.		 */        public function MD2()        {            mesh = (_container = new MovieMesh()) as MovieMesh;                        binary = true;        }    }}